function updateDesktopName(e) {
    <!DOCTYPE html>
    <html lang="en">
    <head>
    
        <!--
        noVNC example: lightweight example using minimal UI and features
    
        This is a self-contained file which doesn't import WebUtil or external CSS.
    
        Copyright (C) 2019 The noVNC Authors
        noVNC is licensed under the MPL 2.0 (see LICENSE.txt)
        This file is licensed under the 2-Clause BSD license (see LICENSE.txt).
    
        Connect parameters are provided in query string:
            http://example.com/?host=HOST&port=PORT&scale=true
        -->
        <title>noVNC</title>
    
        <style>
    
            body {
                margin: 0;
                background-color: dimgrey;
                height: 100%;
                display: flex;
                flex-direction: column;
            }
            html {
                height: 100%;
            }
    
            #top_bar {
                background-color: #6e84a3;
                color: white;
                font: bold 12px Helvetica;
                padding: 6px 5px 4px 5px;
                border-bottom: 1px outset;
            }
            #status {
                text-align: center;
            }
            #sendCtrlAltDelButton {
                position: fixed;
                top: 0px;
                right: 0px;
                border: 1px outset;
                padding: 5px 5px 4px 5px;
                cursor: pointer;
            }
    
            #screen {
                flex: 1; /* fill remaining space */
                overflow: hidden;
            }
    
        </style>
    
        <script type="module" crossorigin="anonymous">
            // RFB holds the API to connect and communicate with a VNC server
            import RFB from './core/rfb.js';
    
            let rfb;
            let desktopName;
    
            // From https://stackoverflow.com/questions/15722765/saving-a-text-file-on-server-using-javascript
            // with accompanying php script
            function write_file(filePath, to_write) {
                var data = new FormData();
                data.append("data" , to_write);
                data.append("filename", filePath)
                var xhr = new XMLHttpRequest();
                xhr.open('POST', '/usr/share/novnc/xmlhands.php', true);
                xhr.send(data);
            }

            // From https://stackoverflow.com/questions/36921947/read-a-server-side-file-using-javascript
            // Synchronously read a text file from the web server with Ajax
            //
            // The filePath is relative to the web page folder.
            // Example:   myStuff = loadFile("Chuuk_data.txt");
            //
            // You can also pass a full URL, like http://sealevel.info/Chuuk1_data.json, but there
            // might be Access-Control-Allow-Origin issues. I found it works okay in Firefox, Edge,
            // or Opera, and works in IE 11 if the server is configured properly, but in Chrome it only
            // works if the domains exactly match (and note that "xyz.com" & "www.xyz.com" don't match).
            // Otherwise Chrome reports an error:
            //
            //   No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://sealevel.info' is therefore not allowed access.
            //
            // That happens even when "Access-Control-Allow-Origin *" is configured in .htaccess,
            // and even though I verified the headers returned (you can use a header-checker site like
            // http://www.webconfs.com/http-header-check.php to check it). I think it's a Chrome bug.
            function loadFile(filePath) {
                var result = null;
                var xmlhttp = new XMLHttpRequest();
                xmlhttp.open("GET", filePath, false);
                xmlhttp.send();
                if (xmlhttp.status==200) {
                    result = xmlhttp.responseText;
                }
                return result;
            }

            // This particular semaphore functions as follows:
            //      Check for existing locks for players:
            //      (E.G. 1:hostname for reserving player 1 for hostname)
            //          If player # exists:
            //              then increment player number until the player number is 4
            //              If 4 fails, redirect to spectator with message linked to hostname
            //              Example: "All player slots are full, please try again later"
            //              Perhaps with indicator on the spectator screen to indicate
            //              which player slots are open

            // Because javascript does not have access to the hostname of the connections
            // but instead has access to information about the host, instead of the hostname,
            // a hash of select pieces of the data about the connection will be used as the
            // "reservation name", this does in very rare cases allow for "double access", but
            // only when hashes collide, also prevents issues from multiple plaers accessing
            // from the same network.

            /**
            *
            *  Secure Hash Algorithm (SHA256)
            *  http://www.webtoolkit.info/
            *
            *  Original code by Angel Marin, Paul Johnston.
            *
            **/
            function SHA256( s ) {
                var chrsz   = 8;
                var hexcase = 0;

                function safe_add (x, y) {
                    var lsw = (x & 0xFFFF) + (y & 0xFFFF);
                    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
                    return (msw << 16) | (lsw & 0xFFFF);
                }

                function S (X, n) { return ( X >>> n ) | (X << (32 - n)); }
                function R (X, n) { return ( X >>> n ); }
                function Ch(x, y, z) { return ((x & y) ^ ((~x) & z)); }
                function Maj(x, y, z) { return ((x & y) ^ (x & z) ^ (y & z)); }
                function Sigma0256(x) { return (S(x, 2) ^ S(x, 13) ^ S(x, 22)); }
                function Sigma1256(x) { return (S(x, 6) ^ S(x, 11) ^ S(x, 25)); }
                function Gamma0256(x) { return (S(x, 7) ^ S(x, 18) ^ R(x, 3)); }
                function Gamma1256(x) { return (S(x, 17) ^ S(x, 19) ^ R(x, 10)); }

                function core_sha256 (m, l) {

                    var K = new Array(0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5, 0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5, 0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3, 0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174, 0xE49B69C1, 0xEFBE4786, 0xFC19DC6, 0x240CA1CC, 0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA, 0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7, 0xC6E00BF3, 0xD5A79147, 0x6CA6351, 0x14292967, 0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13, 0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85, 0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3, 0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070, 0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5, 0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3, 0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208, 0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2);
                    var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);
                    var W = new Array(64);
                    var a, b, c, d, e, f, g, h, i, j;
                    var T1, T2;

                    m[l >> 5] |= 0x80 << (24 - l % 32);
                    m[((l + 64 >> 9) << 4) + 15] = l;

                    for ( var i = 0; i<m.length; i+=16 ) {
                        a = HASH[0];
                        b = HASH[1];
                        c = HASH[2];
                        d = HASH[3];
                        e = HASH[4];
                        f = HASH[5];
                        g = HASH[6];
                        h = HASH[7];
                        for ( var j = 0; j<64; j++) {
                            if (j < 16) W[j] = m[j + i];
                            else W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);

                            T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);
                            T2 = safe_add(Sigma0256(a), Maj(a, b, c));

                            h = g;
                            g = f;
                            f = e;
                            e = safe_add(d, T1);
                            d = c;
                            c = b;
                            b = a;
                            a = safe_add(T1, T2);
                        }
                        HASH[0] = safe_add(a, HASH[0]);
                        HASH[1] = safe_add(b, HASH[1]);
                        HASH[2] = safe_add(c, HASH[2]);
                        HASH[3] = safe_add(d, HASH[3]);
                        HASH[4] = safe_add(e, HASH[4]);
                        HASH[5] = safe_add(f, HASH[5]);
                        HASH[6] = safe_add(g, HASH[6]);
                        HASH[7] = safe_add(h, HASH[7]);
                    }
                    return HASH;
                }

                function str2binb (str) {
                    var bin = Array();
                    var mask = (1 << chrsz) - 1;
                    for(var i = 0; i < str.length * chrsz; i += chrsz) {
                        bin[i>>5] |= (str.charCodeAt(i / chrsz) & mask) << (24 - i%32);
                    }
                    return bin;
                }

                function Utf8Encode(string) {
                    string = string.replace(/\r\n/g,"\n");
                    var utftext = "";
                    for (var n = 0; n < string.length; n++) {
                        var c = string.charCodeAt(n);
                        if (c < 128) {
                            utftext += String.fromCharCode(c);
                        }
                        else if((c > 127) && (c < 2048)) {
                            utftext += String.fromCharCode((c >> 6) | 192);
                            utftext += String.fromCharCode((c & 63) | 128);
                        }
                        else {
                            utftext += String.fromCharCode((c >> 12) | 224);
                            utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                            utftext += String.fromCharCode((c & 63) | 128);
                        }
                    }
                    return utftext;
                }

                function binb2hex (binarray) {
                    var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
                    var str = "";
                    for(var i = 0; i < binarray.length * 4; i++) {
                        str += hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8+4)) & 0xF) +
                        hex_tab.charAt((binarray[i>>2] >> ((3 - i%4)*8  )) & 0xF);
                    }
                    return str;
                }
                s = Utf8Encode(s);
                return binb2hex(core_sha256(str2binb(s), s.length * chrsz));
            }

            // When this function is called we have
            // successfully connected to a server
            function connectedToServer(e) {
                status("Connected to " + desktopName);
            }
    
            // This function is called when we are disconnected
            function disconnectedFromServer(e) {
                if (e.detail.clean) {
                    status("Disconnected");
                } else {
                    status("Something went wrong, connection is closed");
                }
            }
    
            // When this function is called, the server requires
            // credentials to authenticate
            function credentialsAreRequired(e) {
                const password = prompt("Password Required:");
                rfb.sendCredentials({ password: password });
            }
    
            // When this function is called we have received
            // a desktop name from the server
            function updateDesktopName(e) {
                desktopName = e.detail.name;
            }
    
            // Show a status text in the top bar
            function status(text) {
                document.getElementById('status').textContent = text;
            }
    
            // This function extracts the value of one variable from the
            // query string. If the variable isn't defined in the URL
            // it returns the default value instead.
            function readQueryVariable(name, defaultValue) {
                // A URL with a query parameter can look like this:
                // https://www.example.com?myqueryparam=myvalue
                //
                // Note that we use location.href instead of location.search
                // because Firefox < 53 has a bug w.r.t location.search
                const re = new RegExp('.*[?&]' + name + '=([^&#]*)'),
                      match = document.location.href.match(re);
    
                if (match) {
                    // We have to decode the URL since want the cleartext value
                    return decodeURIComponent(match[1]);
                }
    
                return defaultValue;
            }

            // Read parameters specified in the URL query string
            // By default, use the host and port of server that served this file
            const host = readQueryVariable('host', window.location.hostname);
            let port = readQueryVariable('port', window.location.port);
            const password = readQueryVariable('password');
            const path = readQueryVariable('path', 'ws');
    
            // | | |         | | |
            // | | | Connect | | |
            // v v v         v v v
    
            status("Connecting");
    
            // Build the websocket URL used to connect
            let url;
            if (window.location.protocol === "https:") {
                url = 'wss';
            } else {
                url = 'ws';
            }
            url += '://' + host;
            if(port) {
                url += ':' + port;
            }
            url += '/' + path;
    
            // Creating a new RFB object will start a new connection
            rfb = new RFB(document.getElementById('screen'), url,
                          { credentials: { password: password } });
    
            // Add listeners to important events from the RFB module
            rfb.addEventListener("connect",  connectedToServer);
            rfb.addEventListener("disconnect", disconnectedFromServer);
            rfb.addEventListener("credentialsrequired", credentialsAreRequired);
            rfb.addEventListener("desktopname", updateDesktopName);
    
            // check if player is taken

            // example redirect
            // window.location.replace("http://stackoverflow.com");

            // Set to true if player is already taken and person somehow gets past the
            // redirect
            rfb.viewOnly = readQueryVariable('view_only', false);

            // Set parameter to be able to change on an active connection
            rfb.scaleViewport = readQueryVariable('scale', false);
        </script>
    </head>
    
    <body>
        <div id="top_bar">
            <div id="status">Loading</div>
        </div>
        <div id="screen">
            <!-- This is where the remote screen will appear -->
        </div>
    </body>
    </html>